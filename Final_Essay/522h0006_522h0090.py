# -*- coding: utf-8 -*-
"""522H0006_522h0090.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1YUhwN5oerxq3oUyIZDzT9QkW30QvkjkR

**Đặng Thành Nhân-MSSV:522H0006, Võ Nhật Hào-MSSV:522H0090-Nhóm 8 tổ 2-Midterm-Essay**
"""

import numpy as np

# Tạo ma trận A kích thước 10x10 với các phần tử là các số ngẫu nhiên giữa 1 và 100
A = np.random.randint(1, 101, (10, 10))

# Tạo ma trận B kích thước 2x10 với các phần tử là các số ngẫu nhiên giữa 1 và 20
B = np.random.randint(1, 21, (2, 10))

# Tạo ma trận C kích thước 10x2 với các phần tử là các số ngẫu nhiên giữa 1 và 20
C = np.random.randint(1, 21, (10, 2))

print("A = ", A, sep="\n")
print("B = ", B, sep="\n")
print("C = ", C, sep="\n")
print()

print("a)")
#a
A_T = A.T # sử dụng lệnh A.T để chuyển vị ma trận của A
B_T = B.T # sử dụng lệnh B.T để chuyển vị ma trận của B
C_T = C.T # sử dụng lệnh C.T để chuyển vị ma trận của C

# in kết quả
print(A + A_T + np.dot(C, B) + np.dot(B_T, C_T))   # lệnh np.dot là nhân 2 ma trận
print()

print("b)")
#b
# khai báo ma trận D kích thước 10x10 với tất cả phần tử bằng 0
D = np.zeros((10, 10))
# khởi tạo vòng lập for cho i chạy từ 10 đến 19
for i in range(10, 19+1):
    j = i - 9 # j = i - 10
    D += (A/i)**j # cộng giá trị (A/i)^j vào ma trận D
# in kết quả
print(D)
print()

print("c)")
#c
# khai báo ma trận odd_row lưu các hàng lẻ trong ma trận A bằng lệnh 1::2
# lệnh A[1::2] có nghĩa là lấy các hàng trong ma trận A bắt đầu từ hàng có index=1(hàng thứ 2) và bước nhảy là 2
odd_row = A[1::2]
# in ma trận odd_row chứa các hàng lẻ của ma trận A
print("odd_row = ", odd_row, sep="\n")
print()

print("d)")
#d
# duyệt qua từng phần tử có trong ma trận A nếu không chia hết cho 2 thì lưu vào mảng odd_vector
odd_vector = []
for i in A.flatten(): # câu lệnh A.flatten() để chuyển ma trận A thành mảng 1 chiều
  if(i % 2 != 0):
    odd_vector.append(i)
# in ma trận odd_vector chứa các số lẻ có trong ma trận A
print("odd_vector =", odd_vector)
print()

print("e)")
# e
# khai báo hàm boolean is_prime() với tham số n
def is_prime(n):
  # nếu n nhỏ hơn hoặc bằng 1 thì n không phải là số nguyên tố
  if n<=1:
    return False
  # duyệt qua mảng từ 2 đến căn bậc 2 của n+1 kiểm tra xem n có chia hết cho số nào không
  for i in range(2, int(np.sqrt(n))+1):
    if n % i == 0:
      # nếu n chia hết cho bất kì số nào từ 2 đến căn bậc 2 của n+1 thì n không phải là số nguyên tố
      return False
  # nếu n không chia hết cho bất kì số nào từ 2 đến căn bậc 2 của n+1 thì n là số nguyên tố
  return True

# khai báo mảng prime_vectorA rỗng
prime_vectorA = []
# sử dụng hàm flatten() để chuyển ma trận A thành mảng 1 chiều, duyệt qua x phần tử trong mảng A
for x in A.flatten():
  # sử dụng hàm  is_prime để kiểm tra x có phải là số nguyên tố hay không
  if(is_prime(x)):
    # nếu x là số nguyên tố thì lưu x vào mảng prime_vectorA
    prime_vectorA.append(x)
# in mảng prime_vectorA chứa các số nguyên tố có trong ma trận A
print("prime_vectorA =", prime_vectorA)
print()

print("f)")
#f
# khai báo  ma trận D bằng ma trận C nhân với ma trận B
D = np.dot(C, B) # câu lệnh np.dot(C, B) dùng để nhân 2 ma trận C và B

# in ma trận D ban đầu
print("D = ", D, sep="\n")

# duyệt qua i hàng của ma trận D
for i in range(D.shape[0]):   # câu lệnh D.shape[0] dùng để truy xuất số hàng có trong ma trận D
  # nếu hàng thứ i là hàng lẻ thì các phần tử trong hàng sẽ bị đảo ngược
  if i % 2 != 0 :
    D[i] = D[i][::-1] # câu lệnh [::-1] dùng để đảo ngược ma trận

# in ma trận D sau khi đảo ngược các phần tử ở hàng lẻ
print()
print("After reverse the odd rows D = ", D, sep="\n")
print()

print("g)")
# g
# khởi tạo biến max_count để lưu số lượng số nguyên tố lớn nhất tìm thấy trong một hàng của ma trận A
max_count = 0
# khởi tạo ma trận max_rows để lưu hàng có nhiều số nguyên tố nhất trong A
max_rows = []

# duyệt qua i hàng trong ma trận A
for i in range(A.shape[0]): # câu lệnh A.shape[0] dùng để truy xuất số hàng có trong ma trận A
    # khởi tạo biến count để lưu số nguyên tố có trong hàng i
    count = 0
    # duyệt qua hàng j cột trong hàng i
    for j in range(A.shape[1]): # câu lệnh A.shape[1] dùng để truy xuất số cột có trong ma trận A
        # nếu phần tử ở vị trí hàng i, cột j là số nguyên tố thì biến đếm count cộng thêm 1 đơn vị
        if is_prime(A[i,j]):
            count += 1
    # nếu số nguyên tố có trong hàng i lớn hơn giá trị max_count thì lưu hàng i đó vào ma trận max_rows và cập nhật giá trị biến đếm max_count
    if count > max_count:
        max_count = count
        max_rows = [A[i, :]] # câu lệnh A[i, :] dùng để truy xuất các phần tử(cột) có trong hàng i
    # nếu số nguyên tố có trong hàng i bằng giá trị max_count thì lưu hàng i đó vào ma trận max_rows
    elif count == max_count:
        max_rows.append(A[i, :])

# in những hàng có số nguyên tố nhiều nhất trong ma trận A
for row in max_rows:
    print(row)
print()

print("h)")
# h
maxOdd_len = 0  # khởi tạo biến maxOdd_len để lưu độ dài dãy số lẻ liên tiếp dài nhất
maxOdd_rows = []  # khởi tạo ma trận maxOdd_rows để lưu các hàng có dãy số lẻ liên tiếp dài nhất

# duyệt qua i hàng trong ma trận A
for i in range(A.shape[0]): # câu lệnh A.shape[0] dùng để truy xuất số hàng có trong ma trận A
    currentOdd_len = 0  # khởi tạo biến currentOdd_len để lưu độ dài dãy số lẻ liên tiếp hiện tại
    maxOdd_in_row = 0  # khởi tạo biến maxOdd_in_row để lưu độ dài dãy số lẻ liên tiếp dài nhất trong hàng hiện tại

    # duyệt qua j cột trong hàng i
    for j in range(A.shape[1]): # câu lệnh A.shape[1] dùng để truy xuất số cột có trong ma trận A
        # Nếu phần tử là số lẻ, tăng độ dài của chuỗi số lẻ hiện tại
        if A[i,j] % 2 != 0:
            currentOdd_len += 1
            # Nếu độ dài của chuỗi số lẻ hiện tại lớn hơn độ dài số lẻ lớn nhất trong hàng, cập nhật maxOdd_in_row
            if currentOdd_len > maxOdd_in_row:
                maxOdd_in_row = currentOdd_len
        else:
            currentOdd_len = 0  # reset độ dài của chuỗi số lẻ hiện tại

    # Nếu độ dài chuỗi số lẻ lớn nhất trong hàng lớn hơn độ dài số lẻ lớn nhất tìm thấy cho đến nay, cập nhật maxOdd_len và lưu hàng i đó vào maxOdd_rows
    if maxOdd_in_row > maxOdd_len:
        maxOdd_len = maxOdd_in_row
        maxOdd_rows = [A[i, :]] # câu lệnh A[i, :] dùng để truy xuất các phần tử(cột) có trong hàng i
    # Nếu độ dài số lẻ lớn nhất trong hàng bằng với độ dài số lẻ lớn nhất tìm thấy cho đến nay, lưu i đó vào maxOdd_rows
    elif maxOdd_in_row == maxOdd_len:
        maxOdd_rows.append(A[i,:])

# in ra các hàng có dãy số lẻ liên tiếp dài nhất
for row in maxOdd_rows:
    print(row)